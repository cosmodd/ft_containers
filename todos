Containers:
	✔ ft::iterator_traits @done(23-01-12 13:14)
	✔ ft::reverse_iterator @done(23-01-23 10:02)
	✔ ft::enable_if @done(23-01-12 13:14)
	✔ ft::is_integral @done(23-02-13 14:26)
	✔ ft::equal @done(23-02-13 14:30)
	✔ ft::lexicographical_compare @done(23-02-21 12:16)
	✔ ft::pair @done(23-02-21 13:19)
	✔ ft::make_pair @done(23-02-21 13:33)

	Stack<T, Container = ft::vector<T>>:
		✔ Uses ft::vector as default container @done(23-02-21 12:16)
		✔ compatible with other containers @done(23-01-11 12:38)
		Constructors:
			✔ ft::stack::stack(const Container& cont = Container()); @done(23-01-10 16:14)
			✔ ft::stack::stack(const ft::stack& other); @done(23-01-10 16:14)
		Member types:
			✔ Container						container_type; @done(23-01-10 16:14)
			✔ Container::value_type			value_type; @done(23-01-10 16:14)
			✔ Container::reference			reference; @done(23-01-10 16:14)
			✔ Container::const_reference	const_reference; @done(23-01-10 16:14)
			✔ Container::size_type			size_type; @done(23-01-10 16:14)
			✔ protected Container			c; @done(23-01-10 16:14)
		Member functions:
			✔ ft::stack::operator=(const ft::stack& other); @done(23-01-10 16:14)
			✔ ft::stack::empty(void) const; @done(23-01-10 16:14)
			✔ ft::stack::size(void) const; @done(23-01-10 16:14)
			✔ ft::stack::top(void); @done(23-01-10 16:14)
			✔ ft::stack::top(void) const; @done(23-01-10 16:14)
			✔ ft::stack::push(const value_type& value); @done(23-01-10 16:14)
			✔ ft::stack::pop(void); @done(23-01-10 16:14)
		Non-member functions:
			✔ ft::stack::operator==(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)
			✔ ft::stack::operator!=(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)
			✔ ft::stack::operator<(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)
			✔ ft::stack::operator<=(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)
			✔ ft::stack::operator>(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)
			✔ ft::stack::operator>=(const ft::stack& lhs, const ft::stack& rhs); @done(23-01-11 12:38)

	Vector<T, Allocator = std::allocator<T>>:
		Constructors:
			✔ ft::vector::vector(void); @done(23-01-23 16:27)
			✔ ft::vector::vector(const Allocator& alloc); @done(23-01-23 16:27)
			✔ ft::vector::vector(const ft::vector& other); @done(23-01-23 16:27)
			✔ explicit vector( size_type count, const T& value = T(), const Allocator& alloc = Allocator()); @done(23-01-23 16:27)
			✔ template< class InputIt > vector( InputIt first, InputIt last, const Allocator& alloc = Allocator()); @done(23-01-23 16:27)
		Member types:
			✔ T							value_type; @done(23-01-23 10:07)
			✔ Allocator					allocator_type; @done(23-01-23 10:07)
			✔ T&						reference; @done(23-01-23 10:07)
			✔ const T&					const_reference; @done(23-01-23 10:07)
			✔ Allocator::pointer		pointer; @done(23-01-23 10:22)
			✔ Allocator::const_pointer	const_pointer; @done(23-01-23 10:22)
			✔ std::ptrdiff_t			difference_type; @done(23-01-23 10:07)
			✔ std::size_t				size_type; @done(23-01-23 10:07)
			Iterators:
				✔ ft::vector::iterator; @done(23-01-23 11:03)
				✔ ft::vector::const_iterator; @done(23-01-23 11:03)
				✔ ft::vector::reverse_iterator; @done(23-01-23 10:24)
				✔ ft::vector::const_reverse_iterator; @done(23-01-23 10:24)
		Member functions:
			✔ ft::vector::operator=(const ft::vector& other); @done(23-01-30 14:37)
			✔ ft::vector::assign(size_type count, const T& value); @done(23-01-23 16:27)
			✔ template< class InputIt > ft::vector::assign(InputIt first, InputIt last); @done(23-01-23 16:27)
			✔ ft::vector::get_allocator(void) const; @done(23-01-30 13:49)
			Element access:
				✔ ft::vector::at(size_type pos); @done(23-01-30 14:39)
				✔ ft::vector::at(size_type pos) const; @done(23-01-30 14:39)
				✔ ft::vector::operator[](size_type pos); @done(23-01-30 14:39)
				✔ ft::vector::operator[](size_type pos) const; @done(23-01-30 14:39)
				✔ ft::vector::front(void); @done(23-01-30 14:40)
				✔ ft::vector::front(void) const; @done(23-01-30 14:40)
				✔ ft::vector::back(void); @done(23-01-30 14:40)
				✔ ft::vector::back(void) const; @done(23-01-30 14:40)
				✔ ft::vector::data(void); @done(23-01-30 14:40)
				✔ ft::vector::data(void) const; @done(23-01-30 14:40)
			Iterators:
				✔ ft::vector::begin(void); @done(23-01-23 13:11)
				✔ ft::vector::begin(void) const; @done(23-01-23 13:11)
				✔ ft::vector::end(void); @done(23-01-23 13:11)
				✔ ft::vector::end(void) const; @done(23-01-23 13:11)
				✔ ft::vector::rbegin(void); @done(23-01-23 13:11)
				✔ ft::vector::rbegin(void) const; @done(23-01-23 13:11)
				✔ ft::vector::rend(void); @done(23-01-23 13:11)
				✔ ft::vector::rend(void) const; @done(23-01-23 13:11)
			Capacity:
				✔ ft::vector::empty(void) const; @done(23-01-23 14:23)
				✔ ft::vector::size(void) const; @done(23-01-23 14:23)
				✔ ft::vector::max_size(void) const; @done(23-01-23 14:23)
				✔ ft::vector::reserve(size_type new_cap); @done(23-01-27 10:56)
				✔ ft::vector::capacity(void) const; @done(23-01-23 14:23)
			Modifiers:
				✔ ft::vector::clear(void); @done(23-01-23 14:30)
				✔ ft::vector::insert(iterator pos, const T& value); @done(23-01-27 15:20)
				✔ ft::vector::insert(iterator pos, size_type count, const T& value); @done(23-01-27 16:42)
				✔ template< class InputIt > ft::vector::insert(iterator pos, InputIt first, InputIt last); @done(23-01-30 14:54)
				✔ ft::vector::erase(iterator pos); @done(23-01-30 15:06)
				✔ ft::vector::erase(iterator first, iterator last); @done(23-01-30 15:06)
				✔ ft::vector::push_back(const T& value); @done(23-01-27 10:44)
				✔ ft::vector::pop_back(void); @done(23-01-27 10:57)
				✔ ft::vector::resize(size_type count, T val = T()); @done(23-02-14 13:23)
				✔ ft::vector::swap(ft::vector& other); @done(23-02-21 12:16)

		Non-member functions:
			✔ ft::vector::operator==(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::operator!=(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::operator<(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::operator<=(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::operator>(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::operator>=(const ft::vector& lhs, const ft::vector& rhs); @done(23-02-21 12:16)
			✔ ft::vector::swap(ft::vector& lhs, ft::vector& rhs); @done(23-02-21 12:17)

	Map<Key, T, Compare=std::less<Key>, Allocator = std::allocator<std::pair<const Key, T>>>:
		Constructors:
			☐ ft::map::map(void);
			☐ ft::map::map(const Compare& comp, const Allocator& alloc = Allocator());
			☐ template <class InputIterator> ft::map::map(InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& alloc = Allocator());
			☐ ft::map::map(const ft::map& other);
		Member types:
			☐ Key	key_type;
			☐ T	mapped_type;
			☐ std::pair<const Key, T>	value_type;
			☐ Compare	key_compare;
			☐ Allocator	allocator_type;
			☐ T&	mapped_type;
			☐ const T&	mapped_type;
			☐ std::pair<const Key, T>&	reference;
			☐ const std::pair<const Key, T>&	const_reference;
			☐ Allocator::pointer	pointer;
			☐ Allocator::const_pointer	const_pointer;
			☐ std::ptrdiff_t	difference_type;
			☐ std::size_t	size_type;
		Iterators:
			☐ ft::map::iterator;
			☐ ft::map::const_iterator;
			☐ ft::map::reverse_iterator;
			☐ ft::map::const_reverse_iterator;
		Member functions:
			☐ ft::map::operator=(const ft::map& other);
			☐ ft::map::get_allocator(void) const;
			☐ ft::map::at(const Key& key);
			☐ ft::map::at(const Key& key) const;
			☐ ft::map::operator[](const Key& key);
			☐ ft::map::begin(void);
			☐ ft::map::begin(void) const;
			☐ ft::map::end(void);
			☐ ft::map::end(void) const;
			☐ ft::map::rbegin(void);
			☐ ft::map::rbegin(void) const;
			☐ ft::map::rend(void);
			☐ ft::map::rend(void) const;
			☐ ft::map::empty(void) const;
			☐ ft::map::size(void) const;
			☐ ft::map::max_size(void) const;
			☐ ft::map::clear(void);
			☐ ft::map::insert(const value_type& value);
			☐ ft::map::insert(iterator hint, const value_type& value);
			☐ template <class InputIterator> ft::map::insert(InputIterator first, InputIterator last);
			☐ ft::map::erase(iterator pos);
			☐ ft::map::erase(const Key& key);
			☐ ft::map::erase(iterator first, iterator last);
			☐ ft::map::swap(ft::map& other);
			☐ ft::map::count(const Key& key) const;
			☐ ft::map::find(const Key& key);
			☐ ft::map::find(const Key& key) const;
			☐ ft::map::lower_bound(const Key& key);
			☐ ft::map::lower_bound(const Key& key) const;
			☐ ft::map::upper_bound(const Key& key);
			☐ ft::map::upper_bound(const Key& key) const;
			☐ ft::map::equal_range(const Key& key);
			☐ ft::map::equal_range(const Key& key) const;
			☐ ft::map::key_comp(void) const;
			☐ ft::map::value_comp(void) const;
		Non-member functions:
			☐ ft::map::operator==(const ft::map& lhs, const ft::map& rhs);
			☐ ft::map::operator!=(const ft::map& lhs, const ft::map& rhs);
			☐ ft::map::operator<(const ft::map& lhs, const ft::map& rhs);
			☐ ft::map::operator<=(const ft::map& lhs, const ft::map& rhs);
			☐ ft::map::operator>(const ft::map& lhs, const ft::map& rhs);
			☐ ft::map::operator>=(const ft::map& lhs, const ft::map& rhs);
			☐ template <class Key, class T, class Compare, class Allocator> ft::map::swap(ft::map<Key, T, Compare, Allocator>& lhs, ft::map<Key, T, Compare, Allocator>& rhs);
